# 字符串

## 转换

charAt(int x) 截取某个字符

toCharArray() 拆分成字符数组

getBytes() 转化为字节数组

## 比较

equals() 区分大小写

equalsIgnoreCase() 区分大小写

compareTo() 比较大小关系 返回int 值

## 查找

indexOf() 找到则返回第一个字母位置索引，找不到返回-1

lastIndexOf() 从后往前

contains() 判断字符串是否存在 返回boolean

startsWith / endWith 判断字符串数据是否以指定内容开后或结尾

##  替换

replaceAll() 替换所有

replaceFirst() 替换首个

## 截取

substring(int i) 从指定索引截取到结尾

substring(int x ,int y) 截取部分 截取到第y-1位，第y位不截取（一般从第0位开始）

## 拆分

split(" ") 全部拆分

split(" ", int x) 拆分为指定个数

必要时使用转义"\\\\"（表示一个”\\") 对“.”进行转义

concat() 等价于+ 可用来字符串连接

toUpperCase() / toLowerCase() 转换大写或者小写，对于非字母不会进行转换

trim() 去掉字符串左右空格

length() 获取字符串长度

isEmpty() 判断是否为空

initcap()  首字母大写其他小写（需要自己实现，具体参考书本135）







# this关键字

调用本类普通方法：this.方法()

调用本类构造方法：this() 可调用有参或无参

使用this()只能放在构造方法的首行，构造方法互相调用需要保留调用的出口。







# 匿名对象

只能使用唯一一次，下次再用不得不创建一个新对象

使用建议：如果确定一个对象只需要使用唯一的一次，就可以使用匿名对象。

使用匿名对象传参：     *”方法（匿名对象）“*







# Random随机数

1. 导包

   import java.util.Random;

2. 创建

   Random r = new Random(); // 小括号当中留空即可

   

3. 使用

   获取随机int数字（范围是int所有范围，正负）：int num = r.nextInt()

​    获取范围内随机数字： int num = r.nextInt(3)//代表【0,3）就是0~2

​      **r.nextInt(n) + 1 所取范围[1,n]**





# ArrayList

对于此集合来说，直接打印得到不是地址值，而是内容，内容为空，则得到中的空括号:*[ ]*

## 导包

java.util.ArrayList;

## 创建

ArrayList<String> list = new ArrayList<>();

<>里面代表集合中元素类型，泛型只能是引用类型，不能是基本类型;

## 使用

list.add("  李四") //向集合添加数据用到add方法

public boolean add(E e): 向集合添加元素，参数类型与泛型一致。

public E get(int index): 从集合中获取元素，参数是索引编号，返回值就是对应位置的元素。

public E remove(int index): 从集合中删除对应位置元素。

public int size(): 获取集合的尺寸长度，返回值为集合中元素个数

### 存储基本类型

必须使用基本类型对应的包装类

int Interger

char Character

其余基本类型对应包装类都为首字母大写







# Static 关键字

一旦使用static修饰成员方法，那么就成为静态方法，静态方法不属于对象，而属于类的。

如果没有static关键字，必须首先创建对象，然后通过对象才能使用它。

对于本类当中的静态方法，可以省略类名称

静态不能直接访问非静态：内存当中先有静态内容，后有非静态。（先人不知道后人，后人知道先人)

静态方法中不能用this





# 代码块

## 普通代码块

代码块写在方法里 

## 构造块

代码写在类里面

## 静态块

代码块使用static进行定义

多个实例化对象产生时，静态块优先调用，而且只调用一次

静态块优于主方法执行

# Arrays

java.util.Arrays

public static String toString(数组)：将参数数组变为字符串

public static void sort(数组)： 按照升序对数组进行排序







# 继承

共性抽取：父类（基类）子类（派生类）

子类拥有父类内容

子类拥有自己内容

## 定义

public class 父类名称{    }

public class 子类名称 extends 父类名称 {    }

## 使用

子类可以调用父类定义的方法，达到**代码复用**效果

访问方式：

1. 直接通过子类对象访问成员变量

   等号左边是谁就优先用谁，没有则向上找

2. 间接通过成员方法访问成员变量

​        方法属于谁 则优先用谁 没有则向上寻找

## 区分重名问题、

### 局部变量

直接写

### 本类的成员变量

this.成员变量

### 父类成员变量

super.父类成员变量

## 方法重名

创建对象是谁 优先用谁 没有则向上寻找



 ## 方法重写

继承关系中，方法名称一样，参数列表一样

重写：发生在继承关系中，方法名称一样，参数列表一样（覆盖）

重载：方法名称一样，参数列表  不一样

### 特点

创建子类对象，则优先用子类方法

### 注意事项

1. 父子类之间方法名称相同，参数列表也相同

2. @Override 检查是否有效重写

3. 子类方法返回值必须小于等于父类方法返回值范围

4. 子类方法权限必须大于等于父类方法权限修饰符

   [public]() > [protected]() > [default]() >[private]()

   [default]()  不是关键字 而是什么都不写  留空。

   

## 父子类构造方法访问特点

1. 子类构造方法中有一个默认隐含“super()"调用无参构造
2. 可以通过super关键字 使子类构造调用父类重载构造
3. super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造

 # super

1. 在子类的成员方法中，访问父类的成员变量
2. 在子类的成员方法中，访问父类的成员方法
3. 在子类的构造方法中，访问父类构造方法

# 抽象类

## 抽象方法

加上abstract关键字，去掉大括号，直至分号结束

## 抽象类

抽象方法所在的类，必须是抽象类。在class之前写上abstract

## 使用抽象类和抽象方法

1. 不能直接创建new抽象类对象
2. 必须用一个子类来继承抽象父类
3. 子类必须覆盖重写抽象父类当中所有的抽象方法
4. 覆盖重写：子类去掉抽象方法的abstract关键字，然后补上大括号
5. 创建子类对象进行使用

## 注意事项

1. 抽象类不能创建对象，只能创建其非抽象子类的对象
2. 抽象类中可以有构造方法，供子类创建对象时，初始化父类成员使用
3. 抽象类不一定包含抽象方法，但有抽象方法一定是抽象类
4. 抽象类的子类，必须重写抽象父类中的所有抽象方法，否则 编译无法通过，除非子类也是抽象类。





# 接口

定义： public interface 接口名称{  /接口内容}

## 包含内容

 常量、 抽象方法  、默认方法、静态方法

## 接口中抽象方法

public abstract 返回值类型  方法名称(参数列表);

接口中抽象方法，修饰符必须是public abstract（可以选择性省略）

### 使用步骤

1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。

     格式：public class 实现类名称 implements 接口名称{           }

2. 接口实现类 必须覆盖重写接口中所有抽象方法

3. 创建实现类的对象，进行使用

### 注意事项

如果实现类并没有覆盖重写接口中所有的抽象方法，那这个实现类自己必须是一个抽象类。

## 默认方法

public default 返回值类型  方法名称(参数列表) {   方法体  }

接口的默认方法，可以通过接口实现类对象，直接调用

接口的默认方法，也可以被接口实现类进行覆盖重写

## 静态方法

public static 返回值类型  方法名称(参数列表) {   方法体  }

不能通过接口实现类的对象  来调用 接口中的  静态方法

通过接口名称直接调用静态方法

## 私有方法

1. 普通私有方法

   private 返回值类型  方法名称(参数列表) {   方法体  }

2. 静态私有方法

   private static 返回值类型  方法名称(参数列表) {   方法体  }

## 接口的常量

public static final 数据类型  常量名称 = 数据值；

一旦赋值 不可修改

可以省略public static final 

接口中的常量必须赋值，不能不赋值

接口中 常量使用完全大写字母，用下划线分割（推荐命名规则

## 接口注意事项

1. 接口是没有静态代码块或者构造方法
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
3. 如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可
4. 如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类就是一个抽象类
5. 如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6. 一个类如果直接父类当中的方法，和接口中的默认方法产生冲突，那么会优先用父类中的方法。

## 接口之间的多继承

1. 类与类之间是单继承，直接父类只有一个
2. 类与接口之间是多实现的。一个类可以实现多个接口
3. 接口与接口之间是多继承的
4. 多个父接口抽象方法如果重复，没关系；默认方法重复  那么子接口必须进行默认方法的覆盖重写，带有default

# 多态性

## 访问成员变量两种方式：

1. 直接通过对象名称访问 成员变量：等号左边是谁优先用谁，没有则向上找
2. 间接通过成员方法 访问成员变量：看该方法属于谁优先用谁，没有则向上找

在多态代码中，成员方法访问规则：new 的是谁则优先用谁，没有则向上找

   成员方法：                  **编译看左 运行看右**       

成员变量：                   **编译看左，运行看左**

## 向上转型

格式：父类名称 对象名 = new 子类对象();

含义： 创建一个子类对象，把它当做父类来看待使用

## 向下转型

格式：子类名称 子类对象 = (子类名称)父类对象；

含义：将父类对象还原成本来的子类对象。

### 注意事项

1.必须保证对象本来创建的时候，就是该子类对象，才能还原成该子类对象

2.如果对象创建时本来不是该子类对象，非要向下转型成该子类对象，则会报错

### instanceof

对象  instanceof 类名称

得到一个boolean值结果，用来判断前面对象能不能做后面类型的实例

# final

## 修饰类

public final class 类名称 {     }

含义：当前这个类不能有任何子类

注意：一个类如果是final的，其中所有的成员的方法都无法进行覆盖重写

## 修饰方法

当final用来修饰方法时候，这个方法就是最终方法，不能覆盖重写

public final 返回值类型 方法名称（参数列表）{    }

注意事项：对于类、方法来说 abstract和final不能同时使用，因为矛盾

## 修饰局部变量

用final 修饰局部变量，这个变量就不能进行更改

对于基本类型，数据不可改变

对于引用类型，地址值不变，内容可以改变



## 修饰成员变量

用了final之后，必须手动赋值

对于final的成员变量，要么直接赋值，要么通过构造方法赋值

必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值







# 内部类

## 成员内部类

定义格式：修饰符 class 外部类名称{ 修饰符 class   内部类名称 }

注意：内用外，随意访问，外用内，需要内部类对象

### 使用

1. 间接方法：在外部类的方法中，使用内部类，然后main只是调用外部类方法

2. 直接方法：公式： 类名称  对象名称 = new 类名称（）；

   ​                                外部类名称.内部类名称  对象名 = new 外部类名称（）.new内部类名称（）;

### 成员变量重名

格式 ： 外部类名称.this.外部类成员变量名

## 局部内部类

类定义在方法内部。

局部：只有当前所属方法可以使用，出了这个方法就不能用了

定义格式： 修饰符 class  外部类名称{  

​                  修饰符  返回值类型 外部类方法名称（参数列表）{ 

​                class 局部内部类名称{  

​                            /////内容    }  }

局部内部类：如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。

### 匿名内部类

如果接口的实现类（或者父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类。

格式：   接口名称  对象名  = new  接口名称（）{  //    }  ；最后分号

### 注意事项

1. new代表创建对象的动作
2. 接口名称就是匿名内部类需要实现哪个接口
3. {.....}这才是匿名内部类里面的内容
4. 匿名内部类，在创建对象时，只能使用唯一一次。如果想要多次使用，就必须使用单独定义的实现类
5. 匿名对象，在调用方法时，只能调用唯一一次，希望一个对象多次调用方法，必须起名。
6. 匿名内部类省略了（实现类/子类名称），匿名对象省略了对象名称



# Object类

## equals()

==:  比较符 返回一个布尔值

​       基本数据类型 比较的是值

​        引用数据类型 比较两个对象地址值

Object类的equals方法，默认比较两个对象地址值，没有意义

重写equals方法，比较两个对象属性

# 链表

内容长度不确定

1. public void add（数据类型  变量）                向链表中增加新的数据
2. public int  size()          取得链表中保存的元素的个数
3. public boolean isEmpty()              判断是否为空链表
4. public boolean contains(数据类型 变量)    判断某一个数据是否存在
5. public 数据类型 get(int index)        根据索引取得数据
6. public void set(int index,数据类型 变量)    使用新的内容替换指定索引的旧内容
7. public void remove(数据类型 变量)       删除指定数据，如果是对象则要进行对象比较
8. public 数据类型 [] toArray()           将链表以对象数组的形式返回
9. public void clear()                          清空链表